import pygame
from TraductionClass import Traduction

class Manette:
    def __init__(self):
        pygame.joystick.init()
        self.joystick = None
        self.previous_buttons = []
        self.previous_dpad = (0, 0)
        if pygame.joystick.get_count() > 0:
            self.joystick = pygame.joystick.Joystick(0)
            self.joystick.init()
            self.previous_buttons = [0] * self.joystick.get_numbuttons()
        else:
            print("⚠️ Aucune manette détectée !")
    
    def get_dpad(self):
        if self.joystick:
            return self.joystick.get_hat(0)  # Retourne (x, y) de la croix directionnelle
        return (0, 0)
    
    def get_buttons(self):
        if self.joystick:
            return [self.joystick.get_button(i) for i in range(self.joystick.get_numbuttons())]
        return []
    
    def get_button_pressed(self):
        current_buttons = self.get_buttons()
        pressed_buttons = [i for i in range(len(current_buttons)) if current_buttons[i] and not self.previous_buttons[i]]
        self.previous_buttons = current_buttons
        return pressed_buttons
    
    def get_dpad_pressed(self):
        current_dpad = self.get_dpad()
        pressed_dpad = (current_dpad[0] if current_dpad[0] != self.previous_dpad[0] else 0,
                        current_dpad[1] if current_dpad[1] != self.previous_dpad[1] else 0)
        self.previous_dpad = current_dpad
        return pressed_dpad

class SousInterface:
    def __init__(self, parent=None, traduction=None):
        self.traduction = traduction
        self.parent = parent
        self.children = []
        self.active_child = None
        self.running = True
    
    def add_child(self, child):
        self.children.append(child)
    
    def set_active_child(self, child):
        self.active_child = child
    
    def handle_events(self, manette):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
        
        if self.active_child:
            self.active_child.handle_events(manette)
    
    def on_select(self):
        pass
    
    def render(self, screen):
        if self.active_child:
            self.active_child.render(screen)

class DeplacementMenu(SousInterface):
    def __init__(self, parent=None, traduction=None):
        super().__init__(parent, traduction=traduction)
        self.selected_index = 0
    
    def handle_events(self, manette):
        if self.active_child:
            self.active_child.handle_events(manette)
            return        
        
        super().handle_events(manette)
        dpad_x, dpad_y = manette.get_dpad_pressed()
        buttons = manette.get_button_pressed()
        
        if dpad_y == 1:
            self.selected_index = (self.selected_index - 1) % len(self.options)
        elif dpad_y == -1:
            self.selected_index = (self.selected_index + 1) % len(self.options)
        
        if 1 in buttons:  # Bouton A
            self.parent.set_active_child(None)
            
        elif 0 in buttons:  # Bouton A
            self.on_select()
    
    def on_select(self):
        selected_option = self.options[self.selected_index]
        print(f"Option sélectionnée: {selected_option}")
    
    def render(self, screen):
        if self.active_child:
            self.active_child.render(screen)
            return
        
        self.options = [
            self.traduction.traduire("option_automatique"),
            self.traduction.traduire("option_manette"),
            self.traduction.traduire("option_commande"),
        ]
        
        # Récupération de la taille de l'écran
        screen_width, screen_height = screen.get_size()
        
        # Nettoyage de l'écran
        screen.fill((30, 30, 30))

        # Affichage du titre
        font_title = pygame.font.Font(None, screen_height // 12)  # Taille adaptative
        title_surface = font_title.render(self.traduction.traduire("menu_deplacement"), True, (255, 255, 255))
        title_rect = title_surface.get_rect(center=(screen_width // 2, screen_height // 8))
        screen.blit(title_surface, title_rect)

        # Affichage des options
        font = pygame.font.Font(None, screen_height // 15)  # Taille adaptative
        option_spacing = screen_height // 10  # Espacement adaptatif
        start_y = screen_height // 3  # Début des options

        for i, option in enumerate(self.options):
            color = (200, 200, 0) if i == self.selected_index else (255, 255, 255)
            text_surface = font.render(option, True, color)
            text_rect = text_surface.get_rect(center=(screen_width // 2, start_y + i * option_spacing))
            screen.blit(text_surface, text_rect)

        pygame.display.flip()

class ConfigurationMenu(SousInterface):
    def __init__(self, parent=None, traduction=None):
        super().__init__(parent, traduction=traduction)
        self.options = ["Configuration1", "Configuration2", "Configuration3"]
        self.selected_index = 0
    
    def handle_events(self, manette):
        if self.active_child:
            self.active_child.handle_events(manette)
            return
        
        super().handle_events(manette)
        dpad_x, dpad_y = manette.get_dpad_pressed()
        buttons = manette.get_button_pressed()
        
        if dpad_y == 1:
            self.selected_index = (self.selected_index - 1) % len(self.options)
        elif dpad_y == -1:
            self.selected_index = (self.selected_index + 1) % len(self.options)
        
        if 1 in buttons:  # Bouton A
            self.parent.set_active_child(None)
            
        elif 0 in buttons:  # Bouton A
            self.on_select()
    
    def on_select(self):
        selected_option = self.options[self.selected_index]
        print(f"Option sélectionnée: {selected_option}")
    
    def render(self, screen):
        if self.active_child:
            self.active_child.render(screen)
            return
        
        # Récupération de la taille de l'écran
        screen_width, screen_height = screen.get_size()
        
        # Nettoyage de l'écran
        screen.fill((30, 30, 30))

        # Affichage du titre
        font_title = pygame.font.Font(None, screen_height // 12)  # Taille adaptative
        title_surface = font_title.render(self.traduction.traduire("menu_configuration"), True, (255, 255, 255))
        title_rect = title_surface.get_rect(center=(screen_width // 2, screen_height // 8))
        screen.blit(title_surface, title_rect)

        # Affichage des options
        font = pygame.font.Font(None, screen_height // 15)  # Taille adaptative
        option_spacing = screen_height // 10  # Espacement adaptatif
        start_y = screen_height // 3  # Début des options

        for i, option in enumerate(self.options):
            color = (200, 200, 0) if i == self.selected_index else (255, 255, 255)
            text_surface = font.render(option, True, color)
            text_rect = text_surface.get_rect(center=(screen_width // 2, start_y + i * option_spacing))
            screen.blit(text_surface, text_rect)

        pygame.display.flip()

class LangueMenu(SousInterface):
    def __init__(self, parent=None, traduction=None):
        super().__init__(parent, traduction=traduction)
        self.options = ["English", "Français"]
        self.selected_index = 0
    
    def handle_events(self, manette):
        super().handle_events(manette)
        dpad_x, dpad_y = manette.get_dpad_pressed()
        buttons = manette.get_button_pressed()
        
        if dpad_y == 1:
            self.selected_index = (self.selected_index - 1) % len(self.options)
        elif dpad_y == -1:
            self.selected_index = (self.selected_index + 1) % len(self.options)
        
        if 1 in buttons:  # Bouton A
            self.parent.set_active_child(None)
            
        elif 0 in buttons:  # Bouton A
            self.on_select()
    
    def on_select(self):
        nouvelle_langue = "en" if self.selected_index == 0 else "fr"
        self.traduction.changer_langue(nouvelle_langue)
        print(self.traduction.langue)
        print(f"Langue changée en {nouvelle_langue}")
    
    def render(self, screen):
        if self.active_child:
            self.active_child.render(screen)
            return
        
        # Récupération de la taille de l'écran
        screen_width, screen_height = screen.get_size()
        
        # Nettoyage de l'écran
        screen.fill((30, 30, 30))

        # Affichage du titre
        font_title = pygame.font.Font(None, screen_height // 12)  # Taille adaptative
        title_surface = font_title.render(self.traduction.traduire("menu_langue"), True, (255, 255, 255))
        title_rect = title_surface.get_rect(center=(screen_width // 2, screen_height // 8))
        screen.blit(title_surface, title_rect)

        # Affichage des options
        font = pygame.font.Font(None, screen_height // 15)  # Taille adaptative
        option_spacing = screen_height // 10  # Espacement adaptatif
        start_y = screen_height // 3  # Début des options

        for i, option in enumerate(self.options):
            color = (200, 200, 0) if i == self.selected_index else (255, 255, 255)
            text_surface = font.render(option, True, color)
            text_rect = text_surface.get_rect(center=(screen_width // 2, start_y + i * option_spacing))
            screen.blit(text_surface, text_rect)

        pygame.display.flip()

class MenuPrincipal(SousInterface):
    def __init__(self, parent=None, traduction=None):
        super().__init__(parent, traduction=traduction)
        self.selected_index = 0
        self.add_child(DeplacementMenu(self, traduction=traduction))
        self.add_child(ConfigurationMenu(self, traduction=traduction))
        self.add_child(LangueMenu(self, traduction=traduction))
    
    def handle_events(self, manette):
        if self.active_child:
            self.active_child.handle_events(manette)
            return
        
        super().handle_events(manette)
        dpad_x, dpad_y = manette.get_dpad_pressed()
        buttons = manette.get_button_pressed()
        
        if dpad_y == 1:
            self.selected_index = (self.selected_index - 1) % len(self.options)
        elif dpad_y == -1:
            self.selected_index = (self.selected_index + 1) % len(self.options)
        
        if 1 in buttons:  # Bouton A
            self.parent.running = False
            
        elif 0 in buttons:  # Bouton A
            self.on_select()
    
    def on_select(self):
        selected_option = self.options[self.selected_index]
        print(f"Option sélectionnée: {selected_option}")
        self.set_active_child(self.children[self.selected_index])
    
    def render(self, screen):
        if self.active_child:
            self.active_child.render(screen)
            return

        # Mise à jour dynamique des options traduites
        self.options = [
            self.traduction.traduire("menu_deplacement"),
            self.traduction.traduire("menu_configuration"),
            self.traduction.traduire("menu_langue"),
        ]

        # Récupération de la taille de l'écran
        screen_width, screen_height = screen.get_size()
        
        # Nettoyage de l'écran
        screen.fill((30, 30, 30))

        # Affichage du titre
        font_title = pygame.font.Font(None, screen_height // 12)  # Taille adaptative
        title_surface = font_title.render(self.traduction.traduire("menu_principal"), True, (255, 255, 255))
        title_rect = title_surface.get_rect(center=(screen_width // 2, screen_height // 8))
        screen.blit(title_surface, title_rect)

        # Affichage des options
        font = pygame.font.Font(None, screen_height // 15)  # Taille adaptative
        option_spacing = screen_height // 10  # Espacement adaptatif
        start_y = screen_height // 3  # Début des options

        for i, option in enumerate(self.options):
            color = (200, 200, 0) if i == self.selected_index else (255, 255, 255)
            text_surface = font.render(option, True, color)
            text_rect = text_surface.get_rect(center=(screen_width // 2, start_y + i * option_spacing))
            screen.blit(text_surface, text_rect)

        pygame.display.flip()

class InterfaceGlobale:
    def __init__(self, width=1920, height=1080):
        pygame.init()
        self.screen = pygame.display.set_mode((width, height))
        pygame.display.set_caption("Interface PFR")
        
        self.running = True
        self.clock = pygame.time.Clock()
        self.manette = Manette()
        
        self.traduction = Traduction()
        self.root_interface = MenuPrincipal(self, self.traduction)
    
    def run(self):
        while self.running:
            self.root_interface.handle_events(self.manette)
            self.root_interface.render(self.screen)
            self.clock.tick(30)
        pygame.quit()

if __name__ == "__main__":
    interface = InterfaceGlobale()
    interface.run()